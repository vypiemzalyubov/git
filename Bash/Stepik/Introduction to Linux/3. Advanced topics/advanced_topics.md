## 3. Продвинутые темы

### Текстовый редактор vim

Для начала выполнения нажмите кнопку "Open Terminal". Скачайте в открывшемся терминале архив https://stepik.org/media/attachments/course73/byron.txt.gz в директорию `/home/box` и распакуйте его там (для этого вам пригодятся команды `wget` и `gunzip`).

Откройте в vim файл `/home/box/byron.txt`. Удалите все строки с 1001 по 2000 (включительно). Скопируйте строки с 5 по 11 (включительно) и вставьте их в самый конец файла, добавив одну пустую строку перед этой вставкой (т.е. строчка 5 должна следовать за ровно одной пустой строкой, а та за строкой с номером 6277). Замените в тексте все "Harold" на "Ivan".

Сохраните отредактированный файл с именем `/home/box/byron_edited.txt` (это можно сделать прямо из vim!).

```bash
wget https://stepik.org/media/attachments/course73/byron.txt.gz && gunzip ./byron.txt.gz
vim ./byron.txt
:1001,2000d <Enter>
:5,11y <Enter>
<Shift+G>o<Esc>p
:%s/Harold/Ivan/g <Enter>
:﻿w ~/byron_edited.txt <Enter>
:q! <Enter>
```

### Скрипты на bash: основы

Вы можете скачать и изучить скрипт, который мы показали в видеофрагменте: [arguments.sh](https://stepik.org/media/attachments/course73/bash_scripts/arguments.sh).

Напишите скрипт на bash, который принимает на вход два аргумента и выводит на экран строку следующего вида: `Arguments are: $1=первый_аргумент $2=второй_аргумент`.

Например, если ваш скрипт называется `./script.sh`, то при запуске его `./script.sh one two` на экране должно появиться: `Arguments are: $1=one $2=two`, а при запуске `./script.sh three four` будет: `Arguments are: $1=three $2=four`

```bash
vim script1.sh
```
```bash
#!/bin/bash

var1=$1
var2=$2

echo "Arguments are: \$1=${1} \$2=${2}"
```
```bash
chmod + script1.sh
./script1.sh
```
Ссылка на скрипт [script1.sh](https://github.com/vypiemzalyubov/git-bash/blob/main/Bash/Stepik/Introduction%20to%20Linux/3.%20Advanced%20topics/script1.sh)

### Скрипты на bash: ветвления и циклы I

Напишите скрипт на bash, который принимает на вход один аргумент (целое число от 0 до бесконечности), который будет обозначать число студентов в аудитории. В зависимости от значения числа нужно вывести разные сообщения. 

Соответствие входа и выхода должно быть таким:
```bash
0 -->  No students
1 -->  1 student
2 -->  2 students
3 -->  3 students
4 -->  4 students
5 и больше --> A lot of students
```
Примечание а): выводить нужно только строку справа, т.е. "-->" выводить не нужно.

Примечание б): в последней строке слово "lot" с маленькой буквы!

Примечание 2: в этой и всех последующих задачах на написание скриптов, если не указано явно, что нужно проверять вход (например, что он будет именно числом и именно от 0 до бесконечности), то этого делать не нужно!

Пример №1: если ваш скрипт называется ./script.sh, то при запуске его как ./script.sh 1 на экране должно появиться: `1 student`

Пример №2: если ваш скрипт называется ./script.sh, то при запуске его как ./script.sh 5 на экране должно появиться: `A lot of students`

```bash
vim script2.sh
```
```bash
#!/bin/bash

case $1 in
	0) echo "No students";;
	1) echo "$1 student";;
	2 | 3 | 4 ) echo "$1 students";;
	*) echo "A lot of students";;
esac
```
```bash
chmod + script2.sh
./script2.sh
```
Ссылка на скрипт [script2.sh](https://github.com/vypiemzalyubov/git-bash/blob/main/Bash/Stepik/Introduction%20to%20Linux/3.%20Advanced%20topics/script2.sh)

### Скрипты на bash: ветвления и циклы II

Напишите скрипт на bash, который будет определять в какую возрастную группу попадают пользователи. При запуске скрипт должен вывести сообщение "enter your name:" и ждать от пользователя ввода имени (используйте `read`, чтобы прочитать его). Когда имя введено, то скрипт должен написать "enter your age:" и ждать ввода возраста (опять нужен `read`). Когда возраст введен, скрипт пишет на экран "<Имя>, your group is <группа>", где <группа> определяется на основе возраста по следующим правилам:
- младше либо равно 16: "child",
- от 17 до 25 (включительно): "youth",
- старше 25: "adult".

После этого скрипт опять выводит сообщение "enter your name:" и всё начинается по новой (бесконечный цикл!). Если в какой-то момент работы скрипта будет введено пустое имя или возраст 0, то скрипт должен написать на экран "bye" и закончить свою работу (выход из цикла!).

```bash
vim script3.sh
```
```bash
#!/bin/bash

while true
do
    echo enter your name:; read name
    [ -z $name ] && break
    
    echo enter your age:; read age
    [ $age -eq 0 ] && break
    
    if (( $age < 17 )); then
        group=child
    elif (( $age > 25 )); then
        group=adult
    else
        group=youth
    fi
    
    echo "$name, your group is $group"
done
echo bye
```
```bash
chmod + script3.sh
./script3.sh
```
Ссылка на скрипт [script3.sh](https://github.com/vypiemzalyubov/git-bash/blob/main/Bash/Stepik/Introduction%20to%20Linux/3.%20Advanced%20topics/script3.sh)

### Скрипты на bash: разное I

Напишите скрипт на bash, который будет искать наибольший общий делитель (НОД, greatest common divisor, GCD) двух чисел. При запуске ваш скрипт не должен ничего писать на экран, а просто ждет ввода двух натуральных чисел через пробел (для этого можно использовать `read` и указать ему две переменные). После ввода чисел скрипт считает их НОД и выводит на экран сообщение "GCD is <посчитанное значение>", например, для чисел 15 и 25 это будет "GCD is 5". После этого скрипт опять входит в режим ожидания двух натуральных чисел. Если в какой-то момент работы пользователь ввел вместо этого пустую строку, то нужно написать на экран "bye" и закончить свою работу. 

Вычисление НОД несложно реализовать с помощью алгоритма Евклида. Вам нужно написать функцию `gcd`, которая принимает на вход два аргумента (назовем их M и N). Если аргументы равны, то мы нашли НОД -- он равен M (или N), нужно выводить соответствующее сообщение на экран (см. выше). Иначе нужно сравнить аргументы между собой. Если M больше N, то запускаем ту же функцию `gcd`, но в качестве первого аргумента передаем (M-N), а в качестве второго N. Если же наоборот, M меньше N, то запускаем функцию gcd с первым аргументом M, а вторым (N-M).

Примечание: в вызове функции из себя самой нет ничего страшного или неправильного, т.ч. смело вызывайте `gcd` прямо внутри gcd!

Примечание 2: для завершения работы функции в произвольном месте, можно использовать инструкцию `return` (все инструкции функции после `return` выполняться не будут). В отличии от `exit` эта команда завершит только функцию, а не выполнение всего скрипта целиком. Однако в данной задаче можно обойтись и без использования `return`!

```bash
vim script4.sh
```
```bash
#!/bin/bash

gcd ()
{
    if [[ -z $M && -z $N ]]; then
        echo 'bye'
        exit
    fi 
    
    if [[ $M -eq $N ]]; then
        echo "GCD is $M"
    else
        if [[ $M -gt $N ]]; then
            let "M-= $N"
            gcd $M $N        
        else
            let "N -= $M"
            gcd $M $N
        fi
    fi
}

while [[ true ]]; do
    read M N
    gcd $M $N
done
```
```bash
chmod + script4.sh
./script4.sh
```
Ссылка на скрипт [script4.sh](https://github.com/vypiemzalyubov/git-bash/blob/main/Bash/Stepik/Introduction%20to%20Linux/3.%20Advanced%20topics/script4.sh)

### Скрипты на bash: разное II

Напишите калькулятор на bash. При запуске ваш скрипт должен ожидать ввода пользователем команды (при этом на экран выводить ничего не нужно). Команды могут быть трех типов: 
- Слово "exit". В этом случае скрипт должен вывести на экран слово "bye" и завершить работу. 
- Три аргумента через пробел - первый операнд (целое число), операция (одна из "+", "-", "*", "/", "%", "**") и второй операнд (целое число). В этом случае нужно произвести указанную операцию над заданными числами и вывести результат на экран. После этого переходим в режим ожидания новой команды.
- Любая другая команда из одного аргумента или из трех аргументов, но с операцией не из списка. В этом случае нужно вывести на экран слово "error" и завершить работу.

Чтобы проверить работу скрипта, вы можете записать сразу несколько команд в файл и передать его скрипту на stdin (т.е. выполнить `./script.sh < input.txt`). В этом случае он должен вывести сразу все ответы на экран.

Например, если входной файл будет следующего содержания:
```bash
10 + 1
2 ** 10
exit
```
то на экране будет:
```bash
11
1024
bye
```
Если же на вход поступит следующий файл:
```bash
3 - 5
2/10
exit
```
то на экране будет:
```bash
-2
error
```
т.к. вторая команда была некорректной (в ней всего один аргумент, т.к. нет пробелов между числами и операцией, а единственная допустимая команда из одного аргумента это "exit").

```bash
vim script5.sh
```
```bash
#!/bin/bash

while [[ True ]]
do
        read a b c
        if [[ "$a" != "exit" && -z "$b" ]]; then echo "error"; break; fi
        if [[ "$a" == "exit" ]]; then echo "bye"; break; fi
        let res=$a"$b"$c
        echo $res
done
```
```bash
chmod + script5.sh
./script5.sh
```
Ссылка на скрипт [script5.sh](https://github.com/vypiemzalyubov/git-bash/blob/main/Bash/Stepik/Introduction%20to%20Linux/3.%20Advanced%20topics/script5.sh)

### Продвинутый поиск и редактирование

Запишите в форму ниже инструкцию `sed`, которая заменит все "аббревиатуры" в файле `input.txt` на слово "abbreviation" и запишет результат в файл `edited.txt` (на экран при этом ничего выводить не нужно). Обратите внимание, что в инструкции должны быть указаны и сам `sed`, и оба файла!

Под "аббревиатурой" будем понимать слово, которое удовлетворяет следующим условиям: 
- состоит только из больших букв латинского алфавита,
- состоит из хотя бы двух букв,
- окружено одним пробелом с каждой стороны.

При этом будем считать, что в тексте не может быть две "аббревиатуры" подряд. Например, текст  `" YOU YOU and YOU!"` является некорректным (в нем есть две "аббревиатуры", но они идут подряд) и на таких примерах мы проверять вашу инструкцию не будем.

Пример: если у вас был текст `"Hi, I heard these songs by ABBA, TLA and DM !"`, то он должен быть преобразован в `"Hi, I heard these songs by ABBA, abbreviation and abbreviation !"`.

```bash
sed 's/[A-Z]\{2,\} /abbreviation /g' input.txt > edited.txt
```

### Строим графики в gnuplot I

Предположим, что вы пишите gnuplot-скрипт и у вас в нем есть три переменные `x1, x2, x3`, в которых записаны координаты важных точек по оси ОХ (по возрастанию). Вы хотите, чтобы на этой оси было только три деления (т.е. три черточки) в этих самых координатах, а подписи этих делений были оформлены в виде "point <номер точки>, value <значение соответствующей переменной>".

Например, для `x1=0, x2=10, x3=20`, это были бы надписи "point 1, value 0" в точке с координатой 0 по горизонтали,  "point 2, value 10" в точке с координатой 10 и  "point 3, value 20" в точке с координатой 20. Или, например,  `x1=100, x2=150, x3=250`, это были бы надписи "point 1, value 100" в точке с координатой 100, "point 2, value 150" в точке с координатой 150 и "point 3, value 250" в точке с координатой 250. 

Впишите в форму ниже одну команду (т.е. одну строку), которую нужно добавить в скрипт, для выполнения этой задачи.

Примечание: проверять, что переменные `x1, x2, x3` идут по возрастанию или что они являются числами не нужно!

Примечание 2: в видеофрагменте на предыдущем шаге звучал термин конкатенация, который важен для выполнения данного задания. Под конкатенацией обычно понимают "склеивание" двух строк в одну длинную строку, например, конкатенация строк "Данные из файла " и "data.csv" даст строку "Данные из файла data.csv".

```bash
set xtics ("point 1, value ".x1 x1, "point 2, value ".x2 x2, "point 3, value ".x3 x3)
```

### Строим графики в gnuplot II

Если вы не скачали на предыдущем шаге файлы [animated.gnu](https://stepik.org/media/attachments/course73/gnuplot_scripts/animated.gnu) и [move.rot](https://stepik.org/media/attachments/course73/gnuplot_scripts/move.rot), то скачайте их теперь, т.к. они понадобятся для выполнения задания. 

Указанные файлы использовались в последнем видеофрагменте для создания вращающегося графика. Измените инструкции в файле `move.rot` (т.е. добавлять и удалять инструкции нельзя!) таким образом, чтобы:
- График отразился зеркально относительно горизонтальной поверхности. То есть там, где была точка (10, 10, 200), станет точка (10, 10, -200), где была точка  (-10, -10, 200) станет (-10, -10, -200) и т.д. При этом точка (0, 0, 0) останется на месте.
- Изображение стало вращаться в обратную сторону. То есть если раньше вращалось "влево", то теперь станет "вправо".
- Вращение стало в два раза быстрее. То есть станет в два раза больше перерисовок графика на каждую секунду вращения.

Измененный файл загрузите в форму ниже.

Примечание: наша система проверки не может запустить на вашем файле `move.rot` программу gnuplot и сравнить полученный график с заданным. Вместо этого мы анализируем команды, которые вы указали в файле. Поэтому если вы видите, что ваш скрипт в gnuplot работает точно по условию, а мы отвечаем "Incorrect/Неверно", то попробуйте упростить свою модификацию `move.rot` и отправить его еще раз.

```bash
a=a+1
zrot=(zrot+350)%360
set view xrot,zrot
splot -x**2-y**2
pause 0.1
if (a<50) reread
```

## Разное I

Впишите в форму ниже команду, которая выведет сколько места на диске занимает текущая директория (при этом размер нужно вывести в удобном для чтения формате (например, вместо `2048 байт` надо выводить `2.0К`) и больше на экран выводить ничего не нужно). В команде указывайте только необходимые для выполнения задания опции и аргументы, лишних опций указывать не нужно!

```bash
du -h -s
```

## Разное II

Впишите в форму ниже максимально короткую команду (т.е. в которой минимально возможное число символов), которая позволит создать в текущей директории 3 поддиректории с именами `dir1, dir2, dir3`.

```bash
mkdir dir{1..3}
```
